# モデルversion
ersnnv2  
βの推定をスカラにしたモデル  
(v1はβが行列)  
また、βの推定にwindowのデータだけでなく、過去の状態も使用  
（LSTMで推定することでそれを実現）  

## ver1.0
lstmの出力をlinear層にかけてスカラにする  
時間次元とbatch次元をflattenしてやってるから、ちょっと良くないかも？  
目的関数はcrossentropy

## ver2.0
lstmの出力をConv1Dにかけてスカラにする  
こっちのほうがきれいな処理（性能に影響があるかは未知）  
また、目的関数をmse_count_lossとした  
試した感じ、crossentropyよりも精度がいい気がする  
(train_testにおいてcrosentropyは90%いかないが、mseならいく)

## ver2.1
Conv1D + crossentropy + epoch40


# 結果
シーケンス内の速度低下に関しては、どのモデルも強固になった  
一方で、シーケンス内速度増加に関しては、ver1.0のみ強固になった  
どこの挙動が違うのか調べることで、速度増加に対して強固になるような目的関数が作れそう  

βの挙動を調べた結果、2.0のみ空間的な発火率に対してβがきれいに遷移するようになった  
mse lossにしたほうが、βの挙動が良くなるのか...?